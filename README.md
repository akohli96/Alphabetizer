# Alphabetizer

 Alphabetizer simply alphabetizes :smile:
 
[![Build Status](https://travis-ci.com/akohli96/Alphabetizer.svg?branch=master)](https://travis-ci.com/akohli96/Alphabetizer)

## Introduction

   It sorts an input string and removes non-alphabetic characters.

## Technical aspects

Programming language : Java

Continuous integration : Travis-CI

Build automation : Gradle

## Core algorithm

All the core logic can be found in the [server.core directory](src/main/java/server/core)
but essentially inbuilt java features are used to sanitize the input before running it through a comparator.

### Thought process

#### Why streams?
I really enjoy using streams for the functional programming perspective and generally increased readabiliy.
However, since there is a lot of articles like [this](https://jaxenter.com/java-performance-tutorial-how-fast-are-the-java-8-streams-118830.html) and [this](https://blog.overops.com/benchmark-how-java-8-lambdas-and-streams-can-make-your-code-5-times-slower/) I wanted to avoid using them.
I decided to take matters in my own hands and used [JMH](https://openjdk.java.net/projects/code-tools/jmh/) to performance test it.
I found that [streams were faster(marginally)](src/main/resources/performance.txt) so I went ahead and used steams.

#### Why Character over char?
The ```Character class``` is an object where is ```char``` is simply a primitive meaning that using primitives would be less computationally exception.
However, using simply ```char``` I would not be able to use streams without converting them to Characters.
Well, lets pretend I did not use streams. Even then I would not be able to use the inbuilt libraries would not allow for sorting characters as per the use case. I did think of the below
``` java
Arays.sort(charArray)
```
but that would not take into account case insensitivity and comparators do not work with primitives. I could have built my own sorting algorithm that could store additional information in a hashmap of whether something is capital or not and then do a final write on the return but that would bring me into [premature optimization](https://stackify.com/premature-optimization-evil/) teritory which I wanted to avoid.

Hence, Character>char.

I initially had a [CLI app implementation](https://github.com/akohli96/Alphabetizer/tree/f009943924b9bfe3304e9b4b619865f396685789) but wanted to try something different so went for [gRPC](https://grpc.io/).

### gRPC integration

#### "gRPC, what is that?"
gRPC is a high performance remote procedure framework developed by Google that uses protocol buffers for data serialization and HTTP/2 as underlying protocol allowing server and client to communicate.
[HTTP/2](https://developers.google.com/web/fundamentals/performance/http2/) and binary encoding of messages through [protocol buffers](https://developers.google.com/protocol-buffers/) makes it high performance.

#### What is so special about it?
Apart from better performance, it shines when trying to develop polygot applications ie client code written in a different language than the server.
Moreover, services can be generated in a [.proto](src/main/proto/alphabetize.proto) file essentially creating a contract.

After that, client and server code can be generated by a proto compiler to generate it in the language desired.
In this case, both the server and the client code are in Java.

#### How to utilize it once code is generated?
The server application implements the service interfaces and the client application makes remote calls to it, that is all :smile:. 

There was some custom tasks written in the [build.gradle](build.gradle) to easily work with gRPC.
## How do I build and run it?

Please ensure you have [Java 8 SDK](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) installed to ensure it will build on your machine.
Instructions below:
```bash
git clone https://github.com/akohli96/Alphabetizer.git
cd Alphabetizer
./gradlew clean build 
./gradlew runServer
./gradlew runClient --args="'InputString' 'AnotherString'" #Different window
```

### What would I have done differently and/or added?

1. I would have tried to create a library out of [alphabetize](src/main/java/server/core) first and then imported that into the server code.
2. I would have tried to deploy the server as a [docker](https://www.docker.com/) container.